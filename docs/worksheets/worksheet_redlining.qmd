---
title: "redlining"
format: gfm
---

```{r}

library(sf)
library(ggplot2)
library(ggthemes)
library(dplyr)

```


```{r, collapse=TRUE}
# Function to get a list of unique cities and states from the redlining data
get_city_state_list_from_redlining_data <- function() {
  # URL to the GeoJSON data
  url <- "https://raw.githubusercontent.com/americanpanorama/mapping-inequality-census-crosswalk/main/MIv3Areas_2010TractCrosswalk.geojson"
  
  # Read the GeoJSON file into an sf object
  redlining_data <- tryCatch({
    read_sf(url)
  }, error = function(e) {
    stop("Error reading GeoJSON data: ", e$message)
  })

  # Check for the existence of 'city' and 'state' columns
  if (!all(c("city", "state") %in% names(redlining_data))) {
    stop("The required columns 'city' and/or 'state' do not exist in the data.")
  }

  # Extract a unique list of city and state pairs without the geometries
  city_state_df <- redlining_data %>%
    select(city, state) %>%
    st_set_geometry(NULL) %>%  # Drop the geometry to avoid issues with invalid shapes
    distinct(city, state) %>%
    arrange(state, city )  # Arrange the list alphabetically by state, then by city

  # Return the dataframe of unique city-state pairs
  return(city_state_df)
}

```

```{r}
#Retrieve the list of cities and states
city_state_list <- get_city_state_list_from_redlining_data()
print(city_state_list)

```


```{r, collapse=TRUE}
# Function to load and filter redlining data by city
load_city_redlining_data <- function(city_name) {
  # URL to the GeoJSON data
  url <- "https://raw.githubusercontent.com/americanpanorama/mapping-inequality-census-crosswalk/main/MIv3Areas_2010TractCrosswalk.geojson"
  
  # Read the GeoJSON file into an sf object
  redlining_data <- read_sf(url)
  
  # Filter the data for the specified city and non-empty grades
  
  city_redline <- redlining_data %>%
    filter(city == city_name )
  
  # Return the filtered data
  return(city_redline)
}
```

```{r}

# Load redlining data for Denver
denver_redlining <- load_city_redlining_data("Denver")
print(denver_redlining)

```


```{r, collapse=TRUE}
library(osmextract)
library(sf)
library(ggplot2)
library(ggthemes)

get_places <- function(polygon_layer, type = "food" ) {
  # Check if the input is an sf object
  if (!inherits(polygon_layer, "sf")) {
    stop("The provided object is not an sf object.")
  }
  
  # Create a bounding box from the input sf object
  bbox_here <- st_bbox(polygon_layer) |>
    st_as_sfc()
  
  if(type == "food"){
    my_layer <- "multipolygons"
    my_query <- "SELECT * FROM multipolygons WHERE (
                 shop IN ('supermarket', 'bodega', 'market', 'other_market', 'farm', 'garden_centre', 'doityourself', 'farm_supply', 'compost', 'mulch', 'fertilizer') OR
                 amenity IN ('social_facility', 'market', 'restaurant', 'coffee') OR
                 leisure = 'garden' OR
                 landuse IN ('farm', 'farmland', 'row_crops', 'orchard_plantation', 'dairy_grazing') OR
                 building IN ('brewery', 'winery', 'distillery') OR
                 shop = 'greengrocer' OR
                 amenity = 'marketplace'
               )"
    title <- "food"
  }
  
  
  if(type == "natural_habitats"){
    my_layer <- "multipolygons"
    my_query <- "SELECT * FROM multipolygons WHERE (
             boundary = 'protected_area' OR
             natural IN ('tree', 'wood') OR
             landuse = 'forest' OR
             leisure = 'park'
           )"
    title <- "Natural habitats or City owned trees"
  }
  
   if(type == "roads"){
    my_layer <- "lines"
    my_query <- "SELECT * FROM lines WHERE (
             highway IN ('motorway', 'trunk', 'primary', 'secondary', 'tertiary') )"
    title <- "Major roads"
   }
  
  if(type == "rivers"){
    my_layer <- "lines"
    my_query <- "SELECT * FROM lines WHERE (
             waterway IN ('river'))"
    title <- "Major rivers"
  }
  
  # Use the bbox to get data with oe_get(), specifying the desired layer and a custom SQL query for fresh food places
  tryCatch({
    places <- oe_get(
      place = bbox_here,
      layer = my_layer,  # Adjusted layer; change as per actual data availability
      query = my_query,
      quiet = TRUE
    )
    
  places <- st_make_valid(places)
    
    # Crop the data to the bounding box
    cropped_places <- st_crop(places, bbox_here)
    
    # Plotting the cropped fresh food places
    plot <- ggplot(data = cropped_places) +
      geom_sf(fill="cornflowerblue", color="cornflowerblue") +
      ggtitle(title) +
  theme_tufte()+
  theme(legend.position = "none",  # Optionally hide the legend
        axis.text = element_blank(),     # Remove axis text
        axis.title = element_blank(),    # Remove axis titles
        axis.ticks = element_blank(),    # Remove axis ticks
         plot.background = element_rect(fill = "white", color = NA),  # Set the plot background to white
        panel.background = element_rect(fill = "white", color = NA),  # Set the panel background to white
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),
        ) 
    
    # Save the plot as a PNG file
    png_filename <- paste0(title,"_", Sys.Date(), ".png")
    ggsave(png_filename, plot, width = 10, height = 8, units = "in")
    
    # Return the cropped dataset
    return(cropped_places)
  }, error = function(e) {
    stop("Failed to retrieve or plot data: ", e$message)
  })
}



```


```{r}
food <- get_places(denver_redlining, type="food")

natural_habitats <- get_places(denver_redlining, type="natural_habitats")

roads <- get_places(denver_redlining, type="roads")

rivers <- get_places(denver_redlining, type="rivers")


```

```{r}
places_polygons <- rbind(food, natural_habitats)
places_polygons

places_lines <- rbind(roads, rivers)
places_lines
```


```{r, warning=FALSE}

library(sf)
library(ggplot2)
library(ggthemes)
library(dplyr)

# Function to plot city redlining data including various geographic features
plot_city_redlining <- function(redlining_data, filename = "redlining_plot.png") {
  # Fetch additional geographic data based on redlining data
  roads <- get_places(redlining_data, type = "roads")
  rivers <- get_places(redlining_data, type = "rivers")
  
  # Filter residential zones with valid grades and where city survey is TRUE
  residential_zones <- redlining_data %>%
    filter(city_survey == TRUE & grade != "") 

  # Colors for the grades
  colors <- c("#76a865", "#7cb5bd", "#ffff00", "#d9838d")

  # Plot the data using ggplot2
  plot <- ggplot() +
    geom_sf(data = roads, lwd = 0.1) +
    geom_sf(data = rivers, color = "blue", alpha = 0.5, lwd = 1.1) +
    geom_sf(data = residential_zones, aes(fill = grade), alpha = 0.5) +
    theme_tufte() +
    scale_fill_manual(values = colors) +
    labs(fill = 'HOLC Categories') +
    theme(
      plot.background = element_rect(fill = "white", color = NA),
      panel.background = element_rect(fill = "white", color = NA),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      legend.position = "right"
    )
  
  # Save the plot as a high-resolution PNG file
  ggsave(filename, plot, width = 10, height = 8, units = "in", dpi = 600)
  
  # Return the plot object if needed for further manipulation or checking
  return(plot)
}



denver_plot <- plot_city_redlining(denver_redlining)
print(denver_plot)

```


```{r}

residential_zones <- denver_redlining |>
  filter(city_survey == TRUE & grade != "") 

colors <- c( "#76a865","#7cb5bd", "#ffff00", "#d9838d")


ggplot() +
  geom_sf(data=roads, lwd=0.1) +
  geom_sf(data = rivers, col="blue", alpha=0.5, lwd=1.1) +
  geom_sf(data=residential_zones, aes(fill=grade), alpha=0.5) +
  #geom_sf(data=cropped_natural_habitats,color="black", fill="black", alpha=1)+
  theme_tufte()  + 
  scale_fill_manual(values = colors) +
  labs(fill='DENVER \nHOLC Categories')

```



```{r}
library(ggplot2)
library(sf)
library(dplyr)

# Assuming colorado_redline is your sf object with a 'grade' column
# Filter for grades A, B, C, and D
sf_data_filtered <- colorado_redline %>% 
  filter(grade %in% c('A', 'B', 'C', 'D'))

# Define a color for each grade
grade_colors <- c("A" = "#76a865", "B" = "#7cb5bd", "C" = "#ffff00", "D" = "#d9838d")

grade_colors <- c("A" = "black", "B" = "black", "C" = "black", "D" = "black")

# Create the plot with panels for each grade
ggplot(data = sf_data_filtered) +
  geom_sf(data=cropped_highway_network,alpha=0.1, lwd=0.1) +
  geom_sf(data = cropped_river_network, col="blue", alpha=0.1, lwd=1.1) +
  geom_sf(aes(fill = grade)) +
  facet_wrap(~ grade, nrow = 1) +  # Free scales for different zoom levels if needed
  scale_fill_manual(values = grade_colors) +
  theme_minimal() +
  labs(fill = 'HOLC Grade') +
  theme_tufte()+
  theme(legend.position = "none",  # Optionally hide the legend
        axis.text = element_blank(),     # Remove axis text
        axis.title = element_blank(),    # Remove axis titles
        axis.ticks = element_blank(),    # Remove axis ticks
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank())  
```



```{r}
# Load the sf library
library(sf)
library(dplyr)  # for data manipulation

# Example data loading (assumes colorado_redline and cropped_natural_habitats are already loaded)
layer1 <- colorado_redline
layer2 <- cropped_natural_habitats

# Make geometries valid
layer1 <- st_make_valid(layer1)
layer2 <- st_make_valid(layer2)

# Optionally, simplify geometries to remove duplicate vertices
layer1 <- st_simplify(layer1, preserveTopology = TRUE)

# Prepare a list to store results
results <- list()

# Loop through each grade and perform operations
for (grade in c("A", "B", "C", "D")) {
  # Filter layer1 for current grade
  layer1_grade <- layer1[layer1$grade == grade, ]

  # Buffer the geometries of the current grade
  buffered_layer1_grade <- st_buffer(layer1_grade, dist = 100)

  # Intersect with the second layer
  intersections <- st_intersects(layer2, buffered_layer1_grade, sparse = FALSE)
  selected_polygons <- layer2[rowSums(intersections) > 0, ]

  # Add a new column to store the grade information
  selected_polygons$grade <- grade

  # Store the result
  results[[grade]] <- selected_polygons
}

# Combine all selected polygons from different grades into one sf object
final_selected_polygons <- do.call(rbind, results)



```

```{r}
library(ggplot2)

grade_colors <- c("A" = "#76a865", "B" = "#7cb5bd", "C" = "#ffff00", "D" = "#d9838d")
# Assuming 'final_selected_polygons' is your final sf object
# Plot using ggplot2
ggplot(data = final_selected_polygons) +
  geom_sf(aes(fill = grade), color = "black", size = 0.2) +
  scale_fill_manual(values = grade_colors) +
  labs(title = "Selected Polygons by Grade",
       fill = "Grade") +
  theme_minimal() +
  coord_sf()  # Use coord_sf to use the proper aspect ratio

```


```{r}
grade_colors_2 <- c("A" = "black", "B" = "black", "C" = "black", "D" = "black")

# Create the plot with panels for each grade
ggplot(data = sf_data_filtered) +
  geom_sf(data=cropped_highway_network,alpha=0.1, lwd=0.1) +
  geom_sf(data = cropped_river_network, col="blue", alpha=0.1, lwd=1.1) +
  geom_sf(aes(fill = grade)) +
  facet_wrap(~ grade, nrow = 1) +  # Free scales for different zoom levels if needed
  scale_fill_manual(values = grade_colors_2) +
  theme_minimal() +
  labs(fill = 'HOLC Grade') +
  theme_tufte()+
  theme(legend.position = "none",  # Optionally hide the legend
        axis.text = element_blank(),     # Remove axis text
        axis.title = element_blank(),    # Remove axis titles
        axis.ticks = element_blank(),    # Remove axis ticks
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank())+
geom_sf(data = final_selected_polygons, aes(fill = grade), color = "limegreen",fill = "limegreen", size = 0.2) 
```


```{r}

library(sf)
library(httr)

# Assuming the polygon data is loaded into R as an sf object
polygon_data <- colorado_redline |>
  st_make_valid()

# Calculate the centroid of the polygon
centroid <- st_centroid(polygon_data)

# Extract longitude and latitude
coords <- st_coordinates(centroid)
longitude <- coords[1]
latitude <- coords[2]

# Define the base URL for the Historypin API
base_url <- "https://historypin.org/en/api/"

# Construct the API endpoint for searching projects, collections, or pins (assuming pins here)
# Note: Update `path` based on what type of data you are interested in (e.g., "pins")
endpoint <- "pins/nearby"

# Prepare the API URL with query parameters (assuming latitude, longitude, and a radius are valid parameters)
api_url <- paste(base_url, endpoint, "?lat=", latitude, "&lon=", longitude, "&radius=10000", sep="")

# Make the API request
response <- GET(api_url)

# Check the status of the response
if (http_status(response)$category == "success") {
  # Parse the response as JSON
  data <- content(response, "parsed")
  print(data)
} else {
  print("Failed to retrieve data: ")
  print(content(response, "text"))
}


```


```{r}
# Load necessary libraries
library(httr)
library(jsonlite)

# Define the base URL and parameters for the Historypin API
base_url <- "http://www.historypin.org/en/api/"
type <- "pin"

# Parameters for the API call
params <- list(
  limit = 6,
  page = 1,
  sort = "-recent",  # Fetch the most recent pins
  user = 11          # Optionally filter by user ID
)

# Construct the full API URL
url <- paste0(base_url, type, "/listing.json")

# Make the HTTP GET request
response <- GET(url, query = params)

response

# Parse the JSON response
data <- content(response, "parsed")

# Check if 'results' is not empty
if (!is.null(data$results) && length(data$results) > 0) {
    # Extract relevant data into a data frame
    pins_df <- data.frame(
      ID = sapply(data$results, function(x) x$id),
      Caption = sapply(data$results, function(x) x$caption),
      Image_URL = sapply(data$results, function(x) {
        if (!is.null(x$image)) {
          return(paste0("https:", x$image))
        } else {
          return(NA)
        }
      }),
      Description = sapply(data$results, function(x) x$desc),
      User_Name = sapply(data$results, function(x) x$user$name),
      Project = sapply(data$results, function(x) x$project),
      stringsAsFactors = FALSE
    )
    
    # Print the data frame
    print(pins_df)
} else {
    print("No results found.")
}

pins_df
```


```{r}
# Function to load images
load_images <- function(url) {
  tryCatch({
    image <- magick::image_read(url)
    image <- magick::image_scale(image, "100x100")  # Resize for uniformity
    return(image)
  }, error = function(e) {
    return(NA)  # Return NA on error
  })
}

# Apply function to Image_URL column
pins_df$Image <- sapply(pins_df$Image_URL, load_images, USE.NAMES = FALSE)

```

```{r}
# Install and load required packages
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("magick")) install.packages("magick", repos = "http://cran.us.r-project.org")
if (!require("ggimage")) install.packages("ggimage")
library(ggplot2)
library(magick)
library(ggimage)

# Function to load and resize images
load_images <- function(url) {
  tryCatch({
    image <- magick::image_read(url)
    image <- magick::image_scale(image, "100x100")  # Resize images to 100x100 for uniformity
    return(image)
  }, error = function(e) {
    return(NA)  # Return NA if the image fails to load
  })
}

# Correcting the Image URLs in the dataframe
pins_df$Image_URL <- gsub("https:/", "https://", pins_df$Image_URL)

# Function to load and resize images safely
load_images <- function(url) {
  tryCatch({
    # Attempt to read the image from the URL
    image <- magick::image_read(url)
    # Resize image for consistency in the plot
    image <- magick::image_scale(image, "100x100")
    return(image)
  }, error = function(e) {
    # Return NA if there's an error in loading the image
    return(NA)
  })
}

load_images(pins_df$Image_URL[1])

# Apply the function to correct Image_URL column
pins_df$Image <- sapply(pins_df$Image_URL, load_images, USE.NAMES = FALSE)

# Checking if images are loaded (optional, can comment out in production)
print(sum(!is.na(pins_df$Image)), "images loaded successfully.")

# Plot the images using ggplot2 and ggimage
library(ggplot2)
library(ggimage)  # Ensure ggimage is installed and loaded

ggplot(data = pins_df, aes(x = 1, y = ID)) +
  geom_image(aes(image = Image), size = 0.1) +  # Plot images
  theme_minimal() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_text(size = 8)) +
  labs(title = "Images from Historypin", y = "Image ID")

```


```{r}
library(osmextract)
library(sf)
library(ggplot2)

# Assuming colorado_redline is an sf object and bbox_here has been created with st_bbox()
colorado_redline |>
  st_bbox() |>
  st_as_sfc() -> bbox_here

# Use the bbox to get data with oe_get(), specifying the desired layer and a custom SQL query for environmental monitoring stations
monitoring_stations <- oe_get(
  place = bbox_here,
  layer = "points",  # Assuming monitoring stations are best represented as points
  query = "SELECT * FROM points WHERE man_made = 'monitoring_station'",
  quiet = TRUE
)

# Crop the data to the bounding box
cropped_monitoring_stations <- st_crop(monitoring_stations, bbox_here)

# Plotting the cropped environmental monitoring stations
ggplot(data = cropped_monitoring_stations) +
  geom_sf() +
  ggtitle("Environmental Monitoring Stations") +
  theme_minimal()



```